defmodule ATAM4Ex.YAML do
  @moduledoc "Environment config YAML parsing."

  @doc "Read and post-process YAML file, or raise."
  def read!(path) do
    Application.ensure_all_started(:yamerl)

    path
    |> YamlElixir.read_from_file!()
    |> walk!()
  end

  @doc ~S"""
  Post-process YAML generated by YamlElixir/yamerl:

  * Turns string keys into atom keys.
  * Turns pattern `%{":env" => "ENV_VAR"}` into value of `System.get_env("ENV_VAR")`, raising
  if `nil` or empty.
  * Converts `%{":env" => "ENV_VAR", ":as" => "integer"}` value to an integer (or ":as" => "float", a float)
  value.

  ```elixir
  iex> import YamlElixir.Sigil
  ...> yaml = ~y'''
  a: 1
  b:
    c:
    - "hello"
    - "goodbye"
    d:
      :env: "XXXX"
  e:
    :env: "YYYY"
    :as: "float"
  '''
  ...> System.put_env("XXXX", "yyyy")
  ...> System.put_env("YYYY", "10.5")
  ...> ATAM4Ex.YAML.walk!(yaml)
  %{a: 1, b: %{c: ["hello", "goodbye"], d: "yyyy"}, e: 10.5}
  ```
  """
  @spec walk!(data) :: map when data: map
  @spec walk!(data) :: list when data: list
  @spec walk!(data) :: String.t() when data: String.t()
  @spec walk!(data) :: number when data: number
  def walk!(data)

  def walk!(data) when is_map(data) do
    Map.new(data, fn
      {k, %{":env" => "" <> _} = e} -> {key(k), env!(e)}
      {k, v} -> {key(k), walk!(v)}
    end)
  end

  def walk!(data) when is_list(data) do
    Enum.map(data, &walk!/1)
  end

  def walk!(other), do: other

  @spec key(atom | binary) :: any
  def key(key) when is_atom(key), do: key
  def key("" <> key), do: String.to_atom(key)

  def env!(%{":env" => name, ":as" => type}) do
    val = case System.get_env(name) do
      nil -> raise ArgumentError, "ENV var #{name} is missing"
      "" -> raise ArgumentError, "ENV var #{name} is empty string"
      val -> val
    end
    convert!(name, val, String.downcase(type))
  end

  def env!(%{":env" => name}) do
    case System.get_env(name) do
      nil -> raise ArgumentError, "ENV var #{name} is missing"
      "" -> raise ArgumentError, "ENV var #{name} is empty string"
      val -> val
    end
  end

  @spec convert!(binary, binary, binary) :: number
  def convert!(name, val, "integer") do
    case Integer.parse(val) do
      :error -> raise ArgumentError, "ENV var #{name} cannot be converted to an integer: \"#{val}\""
      {val, _} -> val
    end
  end

  def convert!(name, val, "float") do
    case Float.parse(val) do
      :error -> raise ArgumentError, "ENV var #{name} cannot be converted to a float: \"#{val}\""
      {val, _} -> val
    end
  end

end
